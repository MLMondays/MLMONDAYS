<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Blog · &quot;ML Mondays&quot;</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="A weekly USGS-CDI course on image analysis using machine learning"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Blog · &quot;ML Mondays&quot;"/><meta property="og:type" content="website"/><meta property="og:url" content="https://dbuscombe-usgs.github.io/MLMONDAYS/"/><meta property="og:description" content="A weekly USGS-CDI course on image analysis using machine learning"/><meta property="og:image" content="https://dbuscombe-usgs.github.io/MLMONDAYS/img/undraw_online.svg"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://dbuscombe-usgs.github.io/MLMONDAYS/img/undraw_tweetstorm.svg"/><link rel="shortcut icon" href="/MLMONDAYS/img/favicon.ico"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><link rel="alternate" type="application/atom+xml" href="https://dbuscombe-usgs.github.io/MLMONDAYS/blog/atom.xml" title="&quot;ML Mondays&quot; Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://dbuscombe-usgs.github.io/MLMONDAYS/blog/feed.xml" title="&quot;ML Mondays&quot; Blog RSS Feed"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script src="/MLMONDAYS/js/scrollSpy.js"></script><link rel="stylesheet" href="/MLMONDAYS/css/main.css"/><script src="/MLMONDAYS/js/codetabs.js"></script></head><body class="blog"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/MLMONDAYS/"><img class="logo" src="/MLMONDAYS/img/favicon.ico" alt="&quot;ML Mondays&quot;"/><h2 class="headerTitleWithLogo">&quot;ML Mondays&quot;</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/MLMONDAYS/docs/doc1" target="_self">Docs</a></li><li class=""><a href="/MLMONDAYS/docs/doc2" target="_self">Data</a></li><li class=""><a href="/MLMONDAYS/help" target="_self">Help</a></li><li class="siteNavGroupActive siteNavItemActive"><a href="/MLMONDAYS/blog/" target="_self">Blog</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Recent Posts</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Recent Posts</h3><ul class=""><li class="navListItem"><a class="navItem" href="/MLMONDAYS/blog/2020/09/05/blog-post">ML terminology, demystified</a></li><li class="navListItem"><a class="navItem" href="/MLMONDAYS/blog/2020/09/02/blog-post">Tensorflow terminology, demystified</a></li><li class="navListItem"><a class="navItem" href="/MLMONDAYS/blog/2020/09/01/blog-post">Creating a Tensorflow Dataset for an image recognition task</a></li><li class="navListItem"><a class="navItem" href="/MLMONDAYS/blog/2020/08/17/blog-post">Converting between YOLO and PASCAL-VOC object recognition formats, and creating a Tensorflow Dataset</a></li><li class="navListItem"><a class="navItem" href="/MLMONDAYS/blog/2020/08/05/blog-post">Trimming and decompiling a video into png image files, for use in your deep learning project</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer postContainer blogContainer"><div class="wrapper"><div class="posts"><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/MLMONDAYS/blog/2020/09/05/blog-post">ML terminology, demystified</a></h1><p class="post-meta">September 5, 2020</p><div class="authorBlock"><p class="post-authorName"><a href="http://twitter.com/magic_walnut" target="_blank" rel="noreferrer noopener">Dan Buscombe</a></p></div></header><article class="post-content"><div><span><h3><a class="anchor" aria-hidden="true" id="machine-learning-ml-deep-learning-dl-and-artificial-intelligence-ai"></a><a href="#machine-learning-ml-deep-learning-dl-and-artificial-intelligence-ai" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Machine learning (ML), deep learning (DL), and artificial intelligence (AI)</h3>
<h3><a class="anchor" aria-hidden="true" id="data-augmentation"></a><a href="#data-augmentation" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Data augmentation</h3>
</span></div></article></div><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/MLMONDAYS/blog/2020/09/02/blog-post">Tensorflow terminology, demystified</a></h1><p class="post-meta">September 2, 2020</p><div class="authorBlock"><p class="post-authorName"><a href="http://twitter.com/magic_walnut" target="_blank" rel="noreferrer noopener">Dan Buscombe</a></p></div></header><article class="post-content"><div><span><h3><a class="anchor" aria-hidden="true" id="eager-execution"></a><a href="#eager-execution" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>&quot;Eager execution&quot;</h3>
<h3><a class="anchor" aria-hidden="true" id="asynchronous-computation"></a><a href="#asynchronous-computation" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>&quot;Asynchronous computation&quot;</h3>
</span></div></article></div><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/MLMONDAYS/blog/2020/09/01/blog-post">Creating a Tensorflow Dataset for an image recognition task</a></h1><p class="post-meta">September 1, 2020</p><div class="authorBlock"><p class="post-authorName"><a href="http://twitter.com/magic_walnut" target="_blank" rel="noreferrer noopener">Dan Buscombe</a></p></div></header><article class="post-content"><div><span><h3><a class="anchor" aria-hidden="true" id="use-case"></a><a href="#use-case" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Use case</h3>
<p>You have a folder called <code>data</code>, in which there are two additional folders <code>train</code> and <code>test</code>. The <code>train</code> folder contains hundreds to millions of jpeg files, each with a descriptive label in the file name. The <code>test</code> folder contains samples for which we do not yet know the label (we will use our trained model to estimate that). These are jpeg images without any descriptive label in the file name.</p>
<h3><a class="anchor" aria-hidden="true" id="problem"></a><a href="#problem" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Problem:</h3>
<p>We use a GPU (or TPU) to train Deep Neural Networks. To use such 'accelerated hardware' most efficiently, you should feed data fast enough to keep them busy. <em>If your data stored as thousands of individual files (i.e. images), you may not be utilizing your GPU at maximum throughput.</em></p>
<h3><a class="anchor" aria-hidden="true" id="solution"></a><a href="#solution" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Solution:</h3>
<p>You should split your data across several larger files, and stream from multiple files in parallel</p>
<p>For maintaining efficient high-throughput for GPU computation</p>
<p>Tensorflow has strategies for this scenario:</p>
<ol>
<li>First, we batch the numerous small files in a TFRecord file</li>
<li>Then, we use the power of <code>tf.data.Dataset</code> to read from multiple files in parallel.</li>
</ol>
<p>The TFRecord file format is a record-oriented binary format. If your input data are on disk or working with large data then TensorFlow recommended using TFRecord format. You get a significant impact on the performance of your input pipeline. Binary data takes less space on disk, takes less time to copy and can be read more efficiently from disk.</p>
<pre><code class="hljs"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf
<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt
<span class="hljs-title">from</span> tqdm <span class="hljs-keyword">import</span> tqdm
<span class="hljs-title">from</span> matplotlib.image <span class="hljs-keyword">import</span> imread
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-keyword">import</span> os, json, random, requests, glob, math
</code></pre>
<p><code>tf.data.experimental.AUTOTUNE</code>, or simply <code>AUTO</code> is used in the <code>tf.data.Dataset API</code> as a strategy for efficient use of your hardware. It will prompt the <code>tf.data</code> runtime to tune the value dynamically at runtime. This will be used here in the following contexts:</p>
<ol>
<li>set and optimize the number of parallel calls for functions that apply transformations to imagery (cropping, resizing, etc), using <code>dataset.map</code> calls</li>
<li>Set and optimize the number of parallel calls for functions that load data into memory while models train, using <code>dataset.interleave</code> calls</li>
<li>Set and optimize the number of parallel calls for functions that load data into asynchronously memory while models train, using <code>dataset.prefetch</code> calls. These use a background thread and an internal buffer to prefetch elements from the input dataset ahead of the time they are requested.</li>
</ol>
<p>You could familiarize yourself with these topic by following <a href="https://www.tensorflow.org/guide/data">this guide</a> and then <a href="https://www.tensorflow.org/guide/data_performance">this one</a></p>
<pre><code class="hljs">os<span class="hljs-selector-class">.environ</span>[<span class="hljs-string">"TF_DETERMINISTIC_OPS"</span>] = <span class="hljs-string">"1"</span>

SEED=<span class="hljs-number">42</span>
np<span class="hljs-selector-class">.random</span>.seed(SEED)

AUTO = tf<span class="hljs-selector-class">.data</span><span class="hljs-selector-class">.experimental</span><span class="hljs-selector-class">.AUTOTUNE</span>
</code></pre>
<p>You have a folder called <code>data</code>, in which there are two additional folders <code>train</code> and <code>test</code>. The <code>train</code> folder contains hundreds to millions of jpeg files, each with a descriptive label in the file name. The <code>test</code> folder contains samples for which we do not yet know the label (we will use our trained model to estimate that). These are jpeg images without any descriptive label in the file name.</p>
<p>In this example below, we have a folder of more than 250,000 images of cats and dogs. Each jpeg file has either 'cat' or 'dog' in the file name. This workflow would apply to situations where you had more than 2 classes, as I will explain in a later post (illustrated using a different data set)</p>
<h3><a class="anchor" aria-hidden="true" id="creating-tfrecords-of-images-and-discrete-labels"></a><a href="#creating-tfrecords-of-images-and-discrete-labels" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Creating TFRecords of images and discrete labels</h3>
<p>Discrete labels in this sense means two things:</p>
<ol>
<li>There is only one label per image (known as single-label classification, to distingusih from multi-label classification where there are many labels per image)</li>
<li>There is no overlap between labels, such that each label can be represented by a discrete number, i.e. an integer, counting up from zero.</li>
</ol>
<p>We first have to define some variables - how many individual TFRecords per dataset -- called <code>shards</code> -- do we wish to make? (16)</p>
<p>How large are the square images we will use, in pixels? (160)</p>
<p>What are the classes? (cat, and dog, as a list of binary strings). Note that the class labels must be binary strings (<code>b'binary string'</code>) rather than regular strngs (<code>'string'</code>)</p>
<pre><code class="hljs"><span class="hljs-attr">SHARDS</span> = <span class="hljs-number">16</span>
<span class="hljs-attr">TARGET_SIZE</span>=<span class="hljs-number">160</span>
<span class="hljs-attr">CLASSES</span> = [b<span class="hljs-string">'cat'</span>, b<span class="hljs-string">'dog'</span>]
</code></pre>
<p>Next we need to define the number of images in the train directory, <code>nb_images</code>, which is used to define how large each shard will be. Later, <code>nb_images</code> will be used for defining the number of model training and validation steps per epoch - more on that later.</p>
<pre><code class="hljs"><span class="hljs-attr">nb_images</span>=len(tf.io.gfile.glob(<span class="hljs-string">'data/train/*.jpg'</span>))

<span class="hljs-attr">shared_size</span> = math.ceil(<span class="hljs-number">1.0</span> * nb_images / SHARDS)
</code></pre>
<p>To create a TFRecord, we need a function that reads an image from a file, and strips the class name from the file name. This will be different for each dataset and therefore the below function would need modification for each new dataset. In the below, the <code>label</code> is extracted by first stripping the file separator out and removing all the file path before the file name (<code>label = tf.strings.split(img_path, sep='/')</code>), then taking everything before the dot (<code>label = tf.strings.split(label[-1], sep='.')</code>), then finally taking just the first item of the resulting list of file name parts <code>label[0]</code>. The image is simply read in as a binary string of bytes, then reconstructed into the jpeg format using the handy utility <code>tf.image.decode_jpeg</code>.</p>
<pre><code class="hljs">def read_image_and_label(img_path):

  bits = tf.io.read_file(img_path)
  <span class="hljs-built_in">image</span> = tf.<span class="hljs-built_in">image</span>.decode_jpeg(bits)

  <span class="hljs-built_in">label</span> = tf.strings.<span class="hljs-built_in">split</span>(img_path, sep='/')
  <span class="hljs-built_in">label</span> = tf.strings.<span class="hljs-built_in">split</span>(<span class="hljs-built_in">label</span>[-<span class="hljs-number">1</span>], sep='.')

  <span class="hljs-built_in">return</span> <span class="hljs-built_in">image</span>,<span class="hljs-built_in">label</span>[<span class="hljs-number">0</span>]
</code></pre>
<p>Neural nets often use imagery that is not at full resolution, due to memory limitations on GPUs. In this course, downsizing and cropping of imagery will be a fairly common practice. The function below carries out a resizing to the desired <code>TARGET_SIZE</code> (keeping track of which horizontal dimension is the largest), the crops to square</p>
<pre><code class="hljs">def resize_and_crop_image(<span class="hljs-built_in">image</span>, label):
  w = tf.<span class="hljs-built_in">shape</span>(<span class="hljs-built_in">image</span>)[<span class="hljs-number">0</span>]
  h = tf.<span class="hljs-built_in">shape</span>(<span class="hljs-built_in">image</span>)[<span class="hljs-number">1</span>]
  tw = TARGET_SIZE
  th = TARGET_SIZE
  resize_crit = (w * th) / (h * tw)
  <span class="hljs-built_in">image</span> = tf.cond(resize_crit &lt; <span class="hljs-number">1</span>,
                  lambda: tf.<span class="hljs-built_in">image</span>.resize(<span class="hljs-built_in">image</span>, [w*tw/w, h*tw/w]), # <span class="hljs-keyword">if</span> <span class="hljs-keyword">true</span>
                  lambda: tf.<span class="hljs-built_in">image</span>.resize(<span class="hljs-built_in">image</span>, [w*th/h, h*th/h])  # <span class="hljs-keyword">if</span> <span class="hljs-keyword">false</span>
                 )
  nw = tf.<span class="hljs-built_in">shape</span>(<span class="hljs-built_in">image</span>)[<span class="hljs-number">0</span>]
  nh = tf.<span class="hljs-built_in">shape</span>(<span class="hljs-built_in">image</span>)[<span class="hljs-number">1</span>]
  <span class="hljs-built_in">image</span> = tf.<span class="hljs-built_in">image</span>.crop_to_bounding_box(<span class="hljs-built_in">image</span>, (nw - tw) <span class="hljs-comment">// 2, (nh - th) // 2, tw, th)</span>
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">image</span>, label
</code></pre>
<p>When a TFRecord is read back into memory, it is just a string of bytes, so the following function makes sure those bytes get encoded back into jpeg format (with no chroma subsampling)</p>
<pre><code class="hljs">def recompress_image(<span class="hljs-built_in">image</span>, <span class="hljs-built_in">label</span>):
  <span class="hljs-built_in">image</span> = tf.cast(<span class="hljs-built_in">image</span>, tf.uint8)
  <span class="hljs-built_in">image</span> = tf.<span class="hljs-built_in">image</span>.encode_jpeg(<span class="hljs-built_in">image</span>, optimize_size=True, chroma_downsampling=False)
  <span class="hljs-built_in">return</span> <span class="hljs-built_in">image</span>, <span class="hljs-built_in">label</span>
</code></pre>
<p>You should stuff data in a protocol buffer called <code>Example</code>. Example protocol buffer contains <code>Features</code>. The feature is a protocol to describe the data and could have three types: bytes (images), float (floating point labels), and int64 (discrete labels).</p>
<pre><code class="hljs">def <span class="hljs-constructor">_bytestring_feature(<span class="hljs-params">list_of_bytestrings</span>)</span>:
  return tf.train.<span class="hljs-constructor">Feature(<span class="hljs-params">bytes_list</span>=<span class="hljs-params">tf</span>.<span class="hljs-params">train</span>.BytesList(<span class="hljs-params">value</span>=<span class="hljs-params">list_of_bytestrings</span>)</span>)

def <span class="hljs-constructor">_int_feature(<span class="hljs-params">list_of_ints</span>)</span>: # <span class="hljs-built_in">int64</span>
  return tf.train.<span class="hljs-constructor">Feature(<span class="hljs-params">int64_list</span>=<span class="hljs-params">tf</span>.<span class="hljs-params">train</span>.Int64List(<span class="hljs-params">value</span>=<span class="hljs-params">list_of_ints</span>)</span>)

def <span class="hljs-constructor">_float_feature(<span class="hljs-params">list_of_floats</span>)</span>: # float32
  return tf.train.<span class="hljs-constructor">Feature(<span class="hljs-params">float_list</span>=<span class="hljs-params">tf</span>.<span class="hljs-params">train</span>.FloatList(<span class="hljs-params">value</span>=<span class="hljs-params">list_of_floats</span>)</span>)
</code></pre>
<p>We serialize the protocol buffer to a string and write it to a TFRecords files.</p>
<pre><code class="hljs">def <span class="hljs-keyword">to</span><span class="hljs-constructor">_tfrecord(<span class="hljs-params">img_bytes</span>, <span class="hljs-params">label</span>)</span>:  

  class_num = np.argmax(np.<span class="hljs-built_in">array</span>(CLASSES)==label)
  feature = {
      <span class="hljs-string">"image"</span>: <span class="hljs-constructor">_bytestring_feature([<span class="hljs-params">img_bytes</span>])</span>, # one image <span class="hljs-keyword">in</span> the <span class="hljs-built_in">list</span>
      <span class="hljs-string">"class"</span>: <span class="hljs-constructor">_int_feature([<span class="hljs-params">class_num</span>])</span>,        # one <span class="hljs-keyword">class</span> <span class="hljs-keyword">in</span> the <span class="hljs-built_in">list</span>      
  }
  return tf.train.<span class="hljs-constructor">Example(<span class="hljs-params">features</span>=<span class="hljs-params">tf</span>.<span class="hljs-params">train</span>.Features(<span class="hljs-params">feature</span>=<span class="hljs-params">feature</span>)</span>)

</code></pre>
<p>Get a list of files and shuffle them, then create a mapping to link them to the jpeg files so they can be read on the fly</p>
<pre><code class="hljs">dataset = tf.data.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Dataset</span>.</span></span><span class="hljs-built_in">list</span><span class="hljs-constructor">_files('<span class="hljs-params">data</span><span class="hljs-operator">/</span><span class="hljs-params">train</span><span class="hljs-operator">/</span><span class="hljs-operator">*</span>.<span class="hljs-params">jpg</span>', <span class="hljs-params">seed</span>=10000)</span> # This also shuffles the images
dataset = dataset.map(read_image_and_label)
</code></pre>
<p>Next, create a new mapping to the resize and crop function</p>
<pre><code class="hljs"><span class="hljs-attr">dataset</span> = dataset.<span class="hljs-built_in">map</span>(resize_and_crop_image, <span class="hljs-attr">num_parallel_calls=AUTO)</span>  
</code></pre>
<p>Finally, a mapping to the jpeg recompression function, and then set the <code>batch</code> which dictates how many images per shard</p>
<pre><code class="hljs"><span class="hljs-attr">dataset</span> = dataset.map(recompress_image, num_parallel_calls=AUTO)
<span class="hljs-attr">dataset</span> = dataset.batch(shared_size)
</code></pre>
<p>Okay, now the dataset is set up, we can begin writing the data to TFRecords. The following function oads image files, resizes them to a common size and then stores them across <code>NUM_SHARDS</code> TFRecord files. It reads from files in parallel and disregards the order of the data in favour of reading speed. Selecting each (random) pair of image and label sequentially, we call the <code>to_tfrecord</code> function we defined earlier to create the <code>example</code> record, then that is serialized to string and appended to the file. When the requisite number of images for a <code>shard</code> has been reached, a new <code>shard</code> is created.</p>
<pre><code class="hljs">for shard, (image, <span class="hljs-meta">label</span>) <span class="hljs-meta">in</span> enumerate(dataset):
  shard_size = image.numpy().shape[0]
  <span class="hljs-meta">filename</span> = <span class="hljs-string">"cat_dog"</span> + <span class="hljs-string">"{:02d}-{}.tfrec"</span>.<span class="hljs-meta">format</span>(shard, shard_size)

  with tf.io.TFRecordWriter(<span class="hljs-meta">filename</span>) <span class="hljs-meta">as</span> out_file:
    for i <span class="hljs-meta">in</span><span class="hljs-meta"> range(</span>shard_size):
      example = to_tfrecord(image.numpy()[i],<span class="hljs-meta">label</span>.numpy()[i])
      out_file.write(example.SerializeToString())
    p<span class="hljs-meta">rint(</span><span class="hljs-string">"Wrote file {} containing {} records"</span>.<span class="hljs-meta">format</span>(<span class="hljs-meta">filename</span>, shard_size))
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="preparing-for-model-training"></a><a href="#preparing-for-model-training" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Preparing for model training</h3>
<p>We now need some functions to read those TFRecords in and use them during model training. We wish to parallelize the data loading step as much as possible; individual images and labels are small, but there are many thousands of them, so we need to ensure both fast and also consistent rate of data throughput. We acheive this by interleaving the contents of the datasets. The number of datasets to overlap can be specified by the cycle_length argument (set to <code>16</code> here). This is where we also see many of the benefits of <code>tf.data.experimental.AUTOTUNE</code>, or simply <code>AUTO</code> is used in the <code>tf.data.Dataset API</code> to tune the value dynamically at runtime.</p>
<pre><code class="hljs">def get_batched_dataset(filenames):
  <span class="hljs-attr">option_no_order</span> = tf.data.Options()
  option_no_order.<span class="hljs-attr">experimental_deterministic</span> = False

  <span class="hljs-attr">dataset</span> = tf.data.Dataset.list_files(filenames)
  <span class="hljs-attr">dataset</span> = dataset.with_options(option_no_order)
  <span class="hljs-attr">dataset</span> = dataset.interleave(tf.data.TFRecordDataset, <span class="hljs-attr">cycle_length=16,</span> <span class="hljs-attr">num_parallel_calls=AUTO)</span>
  <span class="hljs-attr">dataset</span> = dataset.<span class="hljs-built_in">map</span>(read_tfrecord, <span class="hljs-attr">num_parallel_calls=AUTO)</span>

  <span class="hljs-attr">dataset</span> = dataset.cache() <span class="hljs-comment"># This dataset fits in RAM</span>
  <span class="hljs-attr">dataset</span> = dataset.repeat()
  <span class="hljs-attr">dataset</span> = dataset.shuffle(<span class="hljs-number">2048</span>)
  <span class="hljs-attr">dataset</span> = dataset.batch(BATCH_SIZE, <span class="hljs-attr">drop_remainder=True)</span> <span class="hljs-comment"># drop_remainder will be needed on TPU</span>
  <span class="hljs-attr">dataset</span> = dataset.prefetch(AUTO) <span class="hljs-comment">#</span>

  return dataset
</code></pre>
<p>We call that function for both training and validation subsets, that we will define below</p>
<pre><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_training_dataset</span><span class="hljs-params">()</span></span>:
  <span class="hljs-keyword">return</span> get_batched_dataset(training_filenames)

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_validation_dataset</span><span class="hljs-params">()</span></span>:
  <span class="hljs-keyword">return</span> get_batched_dataset(validation_filenames)
</code></pre>
<p>The following function will read an individual example (random image, label pair) in a TFRecord. Extract the <code>tf.train.Example</code> protocol buffer messages from a TFRecord-format file. Each <code>tf.train.Example</code> record contains one or more “features”, and the input pipeline typically converts these features into tensors.</p>
<pre><code class="hljs">def read_tfrecord(<span class="hljs-built_in">example</span>):
    <span class="hljs-built_in">features</span> = {
        <span class="hljs-string">"image"</span>: tf.io.FixedLenFeature([], tf.<span class="hljs-built_in">string</span>),  # tf.<span class="hljs-built_in">string</span> = bytestring (<span class="hljs-keyword">not</span> text <span class="hljs-built_in">string</span>)
        <span class="hljs-string">"class"</span>: tf.io.FixedLenFeature([], tf.int64),   # shape [] means <span class="hljs-built_in">scalar</span>
    }
    # decode the TFRecord
    <span class="hljs-built_in">example</span> = tf.io.parse_single_example(<span class="hljs-built_in">example</span>, <span class="hljs-built_in">features</span>)

    <span class="hljs-built_in">image</span> = tf.<span class="hljs-built_in">image</span>.decode_jpeg(<span class="hljs-built_in">example</span>['<span class="hljs-built_in">image</span>'], channels=<span class="hljs-number">3</span>)
    <span class="hljs-built_in">image</span> = tf.cast(<span class="hljs-built_in">image</span>, tf.float32) / <span class="hljs-number">255.0</span>
    <span class="hljs-built_in">image</span> = tf.reshape(<span class="hljs-built_in">image</span>, [TARGET_SIZE,TARGET_SIZE, <span class="hljs-number">3</span>])

    class_label = tf.cast(<span class="hljs-built_in">example</span>['class'], tf.int32)

    <span class="hljs-built_in">return</span> <span class="hljs-built_in">image</span>, class_label

</code></pre>
<p>Here we set the batch size. This is a hyperparameter (i.e. set by you, not by model training) and its value is dictated (for the most part) by GPU memory considerations. We are using small imagery, so we can fit a relatively large batch into memory at once. We'll go for something relatively high (&gt; say, 20)</p>
<pre><code class="hljs"><span class="hljs-attr">BATCH_SIZE</span> = <span class="hljs-number">32</span>
</code></pre>
<p>This bit of code just makes sure that the dataset will be read correctly from the TFRecord files. We find them all using <code>glob</code> pattern matching (using 'cat*.tfrec') to form an input dataset, then use the <code>.take()</code> command to grab <code>1</code> batch. Print the labels out to screen - they should be integers. We also print the image dimensions out to ensure they are correct</p>
<pre><code class="hljs"><span class="hljs-attribute">training_filenames</span>=tf.io.gfile.glob('cat*.tfrec')

train_ds = get_training_dataset()
<span class="hljs-keyword">for</span> imgs,lbls <span class="hljs-keyword">in</span> train_ds.take(1):
  <span class="hljs-builtin-name">print</span>(lbls)
  <span class="hljs-builtin-name">print</span>(imgs.shape)
</code></pre>
<p>We wrote all of our images out to TFRecords - we didn't split them into test and validation sets first. That gives us more flexibility to assign train/validation subsets (called <code>splits</code>) here. Below we define <code>VALIDATION_SPLIT</code>, which is the proportion of the total data that will be used for validation. The rest will be used for training. We grab the filenames (again). These are already shuffled, but we can shuffle yet again to ensure the images really do get drawn as randomly as possible from the deck. Then we define train and validation file lists based on the split.</p>
<pre><code class="hljs">VALIDATION_SPLIT = <span class="hljs-number">0.19</span>

filenames=<span class="hljs-keyword">tf</span>.io.gfile.<span class="hljs-built_in">glob</span>(<span class="hljs-string">'cat*.tfrec'</span>)

random.shuffle(filenames)
<span class="hljs-keyword">split</span> = <span class="hljs-keyword">int</span>(<span class="hljs-built_in">len</span>(filenames) * VALIDATION_SPLIT)

training_filenames = filenames[spli<span class="hljs-variable">t:</span>]
validation_filenames = filenames[:<span class="hljs-keyword">split</span>]
</code></pre>
<p>During model training, one epoch provides the model an opportunity to 'see' the entire dataset. So the number of steps per epoch is essentially the number of unique samples of your dataset divided by the batch size.</p>
<pre><code class="hljs">validation_steps = int(<span class="hljs-name">nb_images</span> // len(<span class="hljs-name">filenames</span>) * len(validation_filenames)) // BATCH_SIZE
steps_per_epoch = int(nb_images // len(filenames) * len(<span class="hljs-name">training_filenames</span>)) // BATCH_SIZE  
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="model-training-using-tfrecords"></a><a href="#model-training-using-tfrecords" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Model training using TFRecords</h3>
<p>To demonstrate training using this workflow, we choose a simple (so-called <code>vanilla</code>) model that we construct using a few convolutional filter blocks of increasing size, interspersed with <code>MaxPooling</code> layers, and finally a global pooling and a classifier head layer. This is very similar in design to dozens of examples you can find online using toy datasets such as this. This isn't necessarily the most optimal or powerful model for this or any other dataset, but it'll do fine for demonstration (and will actually likely to be close to optimal considering the relative simplicity of the data/problem)</p>
<pre><code class="hljs">model = tf.keras.Sequential([

    tf.keras.layers.Conv2D(<span class="hljs-attribute">kernel_size</span>=3, <span class="hljs-attribute">filters</span>=16, <span class="hljs-attribute">padding</span>=<span class="hljs-string">'same'</span>, <span class="hljs-attribute">activation</span>=<span class="hljs-string">'relu'</span>, input_shape=[TARGET_SIZE,TARGET_SIZE, 3]),
    tf.keras.layers.Conv2D(<span class="hljs-attribute">kernel_size</span>=3, <span class="hljs-attribute">filters</span>=32, <span class="hljs-attribute">padding</span>=<span class="hljs-string">'same'</span>, <span class="hljs-attribute">activation</span>=<span class="hljs-string">'relu'</span>),
    tf.keras.layers.MaxPooling2D(<span class="hljs-attribute">pool_size</span>=2),

    tf.keras.layers.Conv2D(<span class="hljs-attribute">kernel_size</span>=3, <span class="hljs-attribute">filters</span>=64, <span class="hljs-attribute">padding</span>=<span class="hljs-string">'same'</span>, <span class="hljs-attribute">activation</span>=<span class="hljs-string">'relu'</span>),
    tf.keras.layers.MaxPooling2D(<span class="hljs-attribute">pool_size</span>=2),

    tf.keras.layers.Conv2D(<span class="hljs-attribute">kernel_size</span>=3, <span class="hljs-attribute">filters</span>=128, <span class="hljs-attribute">padding</span>=<span class="hljs-string">'same'</span>, <span class="hljs-attribute">activation</span>=<span class="hljs-string">'relu'</span>),
    tf.keras.layers.MaxPooling2D(<span class="hljs-attribute">pool_size</span>=2),

    tf.keras.layers.Conv2D(<span class="hljs-attribute">kernel_size</span>=3, <span class="hljs-attribute">filters</span>=256, <span class="hljs-attribute">padding</span>=<span class="hljs-string">'same'</span>, <span class="hljs-attribute">activation</span>=<span class="hljs-string">'relu'</span>),

    tf.keras.layers.GlobalAveragePooling2D(),
    tf.keras.layers.Dense(1,<span class="hljs-string">'sigmoid'</span>)
])
</code></pre>
<p>You must <code>.compile</code> your model before you train, giving it an optimizer, loss function and a metric to keep track of. The options below are fairly standard - we use <code>binary_crossentropy</code> -  'binary' because we only have two classes (otherwise you would choose 'categorical') and 'crossentropy' because this is an image recognition problem</p>
<pre><code class="hljs">model.compile(<span class="hljs-attribute">optimizer</span>=<span class="hljs-string">'Adam'</span>,
              <span class="hljs-attribute">loss</span>=<span class="hljs-string">'binary_crossentropy'</span>,
              metrics=[<span class="hljs-string">'accuracy'</span>])
</code></pre>
<p>Call <code>.fit()</code> to train the model</p>
<pre><code class="hljs">model.fit(get_training_dataset(), <span class="hljs-attribute">steps_per_epoch</span>=steps_per_epoch, <span class="hljs-attribute">epochs</span>=10,
                      <span class="hljs-attribute">validation_data</span>=get_validation_dataset(), <span class="hljs-attribute">validation_steps</span>=validation_steps)
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="model-validation"></a><a href="#model-validation" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Model validation</h3>
<p>This little function will convert the integer label into a string label</p>
<pre><code class="hljs">get_label = lambda <span class="hljs-symbol">x</span> : <span class="hljs-string">'cat'</span> <span class="hljs-keyword">if</span> (<span class="hljs-symbol">x</span>==<span class="hljs-number">0</span>) <span class="hljs-keyword">else</span> <span class="hljs-string">'dog'</span>
</code></pre>
<p>Below we call the validation dataset (<code>ds=get_validation_dataset()</code>) and plot one (<code>ds.take(1)</code>) batch. The figure shows 8 x 4 example images, their actual labels and their model-predicted values</p>
<pre><code class="hljs">fig = plt.figure(figsize=(12,28))

<span class="hljs-attribute">cnt</span>=1

<span class="hljs-attribute">ds</span>=get_validation_dataset()

<span class="hljs-keyword">for</span> imgs,lbls <span class="hljs-keyword">in</span> ds.take(1):
  <span class="hljs-attribute">predicted_classes</span>=model.predict_classes(imgs)
  <span class="hljs-keyword">for</span> img,lbl,cl <span class="hljs-keyword">in</span> zip(imgs,lbls,predicted_classes):

    fig.add_subplot(8,4, cnt)
    plt.title(<span class="hljs-string">'obs: {} / est: {}'</span>.format(get_label(lbl),get_label(cl[0])))
    plt.imshow(img)
    plt.axis(<span class="hljs-string">'off'</span>)
    <span class="hljs-attribute">cnt</span>=cnt+1

</code></pre>
<p>We need a new function for model evaluation. This version creates batches, but doesn't <em>repeat</em> them (no <code>dataset.repeat()</code> command)</p>
<pre><code class="hljs">def get_eval_dataset(filenames):
  <span class="hljs-attr">option_no_order</span> = tf.data.Options()
  option_no_order.<span class="hljs-attr">experimental_deterministic</span> = False

  <span class="hljs-attr">dataset</span> = tf.data.Dataset.list_files(filenames)
  <span class="hljs-attr">dataset</span> = dataset.with_options(option_no_order)
  <span class="hljs-attr">dataset</span> = dataset.interleave(tf.data.TFRecordDataset, <span class="hljs-attr">cycle_length=16,</span> <span class="hljs-attr">num_parallel_calls=AUTO)</span>
  <span class="hljs-attr">dataset</span> = dataset.<span class="hljs-built_in">map</span>(read_tfrecord, <span class="hljs-attr">num_parallel_calls=AUTO)</span>

  <span class="hljs-attr">dataset</span> = dataset.cache() <span class="hljs-comment"># This dataset fits in RAM</span>
  <span class="hljs-attr">dataset</span> = dataset.shuffle(<span class="hljs-number">2048</span>)
  <span class="hljs-attr">dataset</span> = dataset.batch(BATCH_SIZE, <span class="hljs-attr">drop_remainder=True)</span> <span class="hljs-comment"># drop_remainder will be needed on TPU</span>
  <span class="hljs-attr">dataset</span> = dataset.prefetch(AUTO) <span class="hljs-comment">#</span>

  return dataset

def get_validation_eval_dataset():
  return get_eval_dataset(validation_filenames)
</code></pre>
<p>To get a global sense of the skill of the model, call <code>.evaluate</code> on the entire validation set, which will use the model for prediction on all validation images, then compare the predicted versus observed labels for each, with what <code>metrics</code> you used when you compiled the model before training (we used <code>accuracy</code>). Print the mean accuracy in percent to screen.</p>
<pre><code class="hljs">loss, accuracy = model.evaluate(get_validation_eval_dataset())
<span class="hljs-builtin-name">print</span>(<span class="hljs-string">'Test Mean Accuracy: '</span>, round((accuracy)<span class="hljs-number">*100</span>, 2))
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="model-deployment"></a><a href="#model-deployment" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Model deployment</h3>
<p>Apply to test (unseen) sample imagery - here I have limited to <code>BATCH_SIZE</code> number of images just for illustration</p>
<pre><code class="hljs">test_filenames = glob.glob(<span class="hljs-string">'data/test1/*.jpg'</span>)[:BATCH_SIZE]
<span class="hljs-function"><span class="hljs-title">len</span><span class="hljs-params">(test_filenames)</span></span>
</code></pre>
<p>For prediction on raw imagery (rather than pre-processed tensors in the TFRecords file), we need a resizing and converting and normalizing function</p>
<pre><code class="hljs"><span class="hljs-function">def <span class="hljs-title">preprocess_image</span><span class="hljs-params">(<span class="hljs-built_in">image</span>)</span>:
  <span class="hljs-built_in">image</span> </span>= tf.<span class="hljs-built_in">image</span>.resize(<span class="hljs-built_in">image</span>, (TARGET_SIZE, TARGET_SIZE))
  <span class="hljs-built_in">image</span> = tf.<span class="hljs-built_in">image</span>.convert_image_dtype(<span class="hljs-built_in">image</span>, tf.float32)
  <span class="hljs-built_in">image</span> = <span class="hljs-built_in">image</span>/<span class="hljs-number">255.</span>
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">image</span>
</code></pre>
<p>Test using one image</p>
<pre><code class="hljs">im = preprocess<span class="hljs-constructor">_image(<span class="hljs-params">imread</span>(<span class="hljs-params">test_filenames</span>[13])</span>)
plt.imshow(im)
</code></pre>
<pre><code class="hljs">predicted_classes=model.predict<span class="hljs-constructor">_classes(<span class="hljs-params">np</span>.<span class="hljs-params">expand_dims</span>(<span class="hljs-params">im</span>,<span class="hljs-params">axis</span>=0)</span>)
get<span class="hljs-constructor">_label(<span class="hljs-params">predicted_classes</span>.<span class="hljs-params">squeeze</span>()</span>)
</code></pre>
<p>Test on a whole batch</p>
<pre><code class="hljs">imgs = <span class="hljs-literal">[]</span>
predicted_classes = <span class="hljs-literal">[]</span>
for f <span class="hljs-keyword">in</span> test_filenames:
  im = preprocess<span class="hljs-constructor">_image(<span class="hljs-params">imread</span>(<span class="hljs-params">f</span>)</span>)
  imgs.append(im)
  predicted_classes.append(<span class="hljs-built_in">int</span>(model.predict<span class="hljs-constructor">_classes(<span class="hljs-params">np</span>.<span class="hljs-params">expand_dims</span>(<span class="hljs-params">im</span>,<span class="hljs-params">axis</span>=0)</span>).squeeze<span class="hljs-literal">()</span>.astype('<span class="hljs-built_in">int</span>')))
</code></pre>
<p>Make a similar plot as before, but this time we only have the model predicted class, not the ground truth class</p>
<pre><code class="hljs">fig = plt.figure(figsize=(<span class="hljs-number">12</span>,<span class="hljs-number">28</span>))

cnt=<span class="hljs-number">1</span>
<span class="hljs-keyword">for</span> img,cl <span class="hljs-keyword">in</span> zip(imgs,predicted_classes):
  fig.add_subplot(<span class="hljs-number">8</span>,<span class="hljs-number">4</span>, cnt)
  plt.title(<span class="hljs-string">'est: {}'</span>.format(get_label(cl)))
  plt.imshow(img)
  plt.axis(<span class="hljs-string">'off'</span>)
  cnt=cnt+<span class="hljs-number">1</span>
</code></pre>
</span></div></article></div><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/MLMONDAYS/blog/2020/08/17/blog-post">Converting between YOLO and PASCAL-VOC object recognition formats, and creating a Tensorflow Dataset</a></h1><p class="post-meta">August 17, 2020</p><div class="authorBlock"><p class="post-authorName"><a href="http://twitter.com/magic_walnut" target="_blank" rel="noreferrer noopener">Dan Buscombe</a></p></div></header><article class="post-content"><div><span><p>This blog post walks through the (somewhat cumbersome - I won't lie!) process of converting between YOLO and PASCAL-VOC 'bounding box' annotation data formats for image recognition problems.</p>
<p>The files we create using <code>makesense.ai</code> and downloaded in <code>YOLO</code> format with the <code>.txt</code> extension can be converted to the <code>PASCAL-VOC</code> format with the <code>.xml</code> extension. This blog post shows you how to do that with python. I also show you how to convert to a generic csv format that is also sometimes used. Finally, I show you how to convert your <code>PASCAL-VOC</code> format data into a Tensorflow <a href="https://www.tensorflow.org/tutorials/load_data/tfrecord">TFRecord</a> that use <a href="https://developers.google.com/protocol-buffers/">Protocol buffers</a>, which are a cross-platform, cross-language library for efficient serialization of structured data.</p>
<h3><a class="anchor" aria-hidden="true" id="resources-i-used"></a><a href="#resources-i-used" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Resources I used</h3>
<p><a href="https://www.tensorflow.org/datasets/add_dataset">These</a> Tensorflow instructions for how to add a dataset, as well as some more specific Tensorflow object detection <a href="https://github.com/tensorflow/models/blob/master/research/object_detection/g3doc/preparing_inputs.md">workflows</a>, and finally the Tensorflow <a href="https://github.com/tensorflow/models">Model Garden</a>, which you'll use here. <a href="https://github.com/datitran/raccoon_dataset">This</a> and <a href="https://towardsdatascience.com/object-detection-tensorflow-854c7eb65fa">this</a> gave some outdated advice that was nevertheless useful, if not used here. <a href="https://www.tensorflow.org/tutorials/load_data/tfrecord">This</a> provides more details on TFRecords and their usages.</p>
<h3><a class="anchor" aria-hidden="true" id="first-dealing-with-empty-imageryannotations"></a><a href="#first-dealing-with-empty-imageryannotations" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>First, dealing with 'empty' imagery/annotations</h3>
<p>We first need to make sure there is a txt file for every image. Any <em>missing</em> .txt files are for images with no annotations (i.e. no people). So, we create an empty txt file with the right name if it is missing.</p>
<p>We only need two libraries for this:</p>
<pre><code class="hljs"><span class="hljs-keyword">import</span> os, glob
</code></pre>
<p>And one <code>for-loop</code> that iterates through each folder of images (<code>test</code>, <code>train</code>, and <code>validation</code> in the example below). If a certain .txt file is missing, it simply creates an empty one</p>
<pre><code class="hljs"><span class="hljs-keyword">for</span> cond in [<span class="hljs-string">'test'</span>, <span class="hljs-string">'train'</span>,<span class="hljs-string">'validation'</span>]:

    jpg = <span class="hljs-built_in">glob</span>.<span class="hljs-built_in">glob</span>(cond+<span class="hljs-string">'/*.jpg'</span>)

    <span class="hljs-keyword">for</span> <span class="hljs-keyword">f</span> in jp<span class="hljs-variable">g:</span>
       file_query = <span class="hljs-keyword">f</span>.replace(<span class="hljs-string">'jpg'</span>,<span class="hljs-string">'txt'</span>).replace(cond, cond+<span class="hljs-string">'_labels'</span>)
       <span class="hljs-keyword">if</span> os.path.isfile(file_query):
          pass
       <span class="hljs-keyword">else</span>:
          <span class="hljs-keyword">print</span>(<span class="hljs-string">"Creating %s"</span> % (file_query))
          with <span class="hljs-keyword">open</span>(file_query, <span class="hljs-string">'w'</span>) <span class="hljs-keyword">as</span> fp:
             pass
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="second-yolo-to-pascal-voc-format-conversion"></a><a href="#second-yolo-to-pascal-voc-format-conversion" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Second, YOLO to PASCAL-VOC format conversion</h3>
<p>PASCAL-VOC is a very common object recognition data format, probably more common than the YOLO format. Many example workflows will use either one of these two formats. Here we convert YOLO (<code>.txt</code>) format to PASCAL-VOC (<code>.xml</code>).</p>
<p>Let's set up the problem. Define an <code>IMG_PATH</code> containing jpg images (in the example below, called <code>test</code>), and a corresponding folder containing the associated .txt files (called <code>test_labels</code> below). This is what my file paths look like on my Linux box:</p>
<pre><code class="hljs"><span class="hljs-attr">IMG_PATH</span> = <span class="hljs-string">"/media/marda/TWOTB/USGS/SOFTWARE/MLMONDAYS/2_ObjRecog/test"</span>

<span class="hljs-comment"># txt_folder is txt file root that using makesense.ai rectbox</span>
<span class="hljs-attr">txt_folder</span> = <span class="hljs-string">"/media/marda/TWOTB/USGS/SOFTWARE/MLMONDAYS/2_ObjRecog/test_labels"</span>
</code></pre>
<p>We define a list of labels. We only have one label, <code>person</code></p>
<pre><code class="hljs">fw = os.listdir(IMG_PATH)
<span class="hljs-comment"># path of save xml file</span>
save_path = <span class="hljs-string">''</span> <span class="hljs-comment"># keep it blank</span>

labels = [<span class="hljs-string">'person'</span>]
global <span class="hljs-keyword">label</span><span class="bash">
label = <span class="hljs-string">''</span></span>
</code></pre>
<p>Some utilities:</p>
<pre><code class="hljs">def csvread(fn):
    <span class="hljs-keyword">with</span> <span class="hljs-keyword">open</span>(fn, <span class="hljs-string">'r'</span>) <span class="hljs-keyword">as</span> csvfile:
        list_arr = []
        reader = csv.reader(csvfile, delimiter=<span class="hljs-string">' '</span>)
        <span class="hljs-keyword">for</span> <span class="hljs-keyword">row</span> <span class="hljs-keyword">in</span> reader:
            list_arr.append(<span class="hljs-keyword">row</span>)
    <span class="hljs-keyword">return</span> list_arr

<span class="hljs-keyword">def</span> convert_label(txt_file):
    <span class="hljs-keyword">global</span> label
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-keyword">range</span>(<span class="hljs-keyword">len</span>(labels)):
        <span class="hljs-keyword">if</span> txt_file[<span class="hljs-number">0</span>] == <span class="hljs-keyword">str</span>(i):
            label = labels[i]
            <span class="hljs-keyword">return</span> label
    <span class="hljs-keyword">return</span> label
</code></pre>
<p>This is the code that extract the info from a YOLO record:</p>
<pre><code class="hljs">def extract_coor(txt_file, img_width, img_height):
    x_rect_mid = <span class="hljs-built_in">float</span>(txt_file[<span class="hljs-number">1</span>])
    y_rect_mid = <span class="hljs-built_in">float</span>(txt_file[<span class="hljs-number">2</span>])
    width_rect = <span class="hljs-built_in">float</span>(txt_file[<span class="hljs-number">3</span>])
    height_rect = <span class="hljs-built_in">float</span>(txt_file[<span class="hljs-number">4</span>])

    x_min_rect = ((<span class="hljs-number">2</span> * x_rect_mid * img_width) - (width_rect * img_width)) / <span class="hljs-number">2</span>
    x_max_rect = ((<span class="hljs-number">2</span> * x_rect_mid * img_width) + (width_rect * img_width)) / <span class="hljs-number">2</span>
    y_min_rect = ((<span class="hljs-number">2</span> * y_rect_mid * img_height) -
                  (height_rect * img_height)) / <span class="hljs-number">2</span>
    y_max_rect = ((<span class="hljs-number">2</span> * y_rect_mid * img_height) +
                  (height_rect * img_height)) / <span class="hljs-number">2</span>

    <span class="hljs-keyword">return</span> x_min_rect, x_max_rect, y_min_rect, y_max_rect
</code></pre>
<p>Loop through each file (in <code>fw</code>) and carry out the conversion, writing one <code>xml</code> format file for each <code>txt</code> file you have</p>
<pre><code class="hljs">for line <span class="hljs-keyword">in</span> fw:
    <span class="hljs-attr">root</span> = etree.Element(<span class="hljs-string">"annotation"</span>)

    <span class="hljs-comment"># try debug to check your path</span>
    <span class="hljs-attr">img_style</span> = IMG_PATH.split('/')[-<span class="hljs-number">1</span>]
    <span class="hljs-attr">img_name</span> = line
    <span class="hljs-attr">image_info</span> = IMG_PATH + <span class="hljs-string">"/"</span> + line
    <span class="hljs-attr">img_txt_root</span> = txt_folder + <span class="hljs-string">"/"</span> + line[:-<span class="hljs-number">4</span>]
    <span class="hljs-comment"># print(img_txt_root)</span>
    <span class="hljs-attr">txt</span> = <span class="hljs-string">".txt"</span>

    <span class="hljs-attr">txt_path</span> = img_txt_root + txt
    <span class="hljs-comment"># print(txt_path)</span>
    <span class="hljs-attr">txt_file</span> = csvread(txt_path)

    <span class="hljs-comment"># read the image  information</span>
    <span class="hljs-attr">img_size</span> = Image.open(image_info).size

    <span class="hljs-attr">img_width</span> = img_size[<span class="hljs-number">0</span>]
    <span class="hljs-attr">img_height</span> = img_size[<span class="hljs-number">1</span>]
    <span class="hljs-attr">img_depth</span> = Image.open(image_info).layers

    <span class="hljs-attr">folder</span> = etree.Element(<span class="hljs-string">"folder"</span>)
    folder.<span class="hljs-attr">text</span> = <span class="hljs-string">"%s"</span> % (img_style)

    <span class="hljs-attr">filename</span> = etree.Element(<span class="hljs-string">"filename"</span>)
    filename.<span class="hljs-attr">text</span> = <span class="hljs-string">"%s"</span> % (img_name)

    <span class="hljs-attr">path</span> = etree.Element(<span class="hljs-string">"path"</span>)
    path.<span class="hljs-attr">text</span> = <span class="hljs-string">"%s"</span> % (IMG_PATH)

    <span class="hljs-attr">source</span> = etree.Element(<span class="hljs-string">"source"</span>)

    <span class="hljs-attr">source_database</span> = etree.SubElement(source, <span class="hljs-string">"database"</span>)
    source_database.<span class="hljs-attr">text</span> = <span class="hljs-string">"Unknown"</span>

    <span class="hljs-attr">size</span> = etree.Element(<span class="hljs-string">"size"</span>)
    <span class="hljs-attr">image_width</span> = etree.SubElement(size, <span class="hljs-string">"width"</span>)
    image_width.<span class="hljs-attr">text</span> = <span class="hljs-string">"%d"</span> % (img_width)

    <span class="hljs-attr">image_height</span> = etree.SubElement(size, <span class="hljs-string">"height"</span>)
    image_height.<span class="hljs-attr">text</span> = <span class="hljs-string">"%d"</span> % (img_height)

    <span class="hljs-attr">image_depth</span> = etree.SubElement(size, <span class="hljs-string">"depth"</span>)
    image_depth.<span class="hljs-attr">text</span> = <span class="hljs-string">"%d"</span> % (img_depth)

    <span class="hljs-attr">segmented</span> = etree.Element(<span class="hljs-string">"segmented"</span>)
    segmented.<span class="hljs-attr">text</span> = <span class="hljs-string">"0"</span>

    root.append(folder)
    root.append(filename)
    root.append(path)
    root.append(source)
    root.append(size)
    root.append(segmented)

    for ii <span class="hljs-keyword">in</span> range(len(txt_file)):
        <span class="hljs-attr">label</span> = convert_label(txt_file[ii][<span class="hljs-number">0</span>])
        x_min_rect, x_max_rect, y_min_rect, <span class="hljs-attr">y_max_rect</span> = extract_coor(
            txt_file[ii], img_width, img_height)

        <span class="hljs-attr">object</span> = etree.Element(<span class="hljs-string">"object"</span>)
        <span class="hljs-attr">name</span> = etree.SubElement(object, <span class="hljs-string">"name"</span>)
        name.<span class="hljs-attr">text</span> = <span class="hljs-string">"%s"</span> % (label)

        <span class="hljs-attr">pose</span> = etree.SubElement(object, <span class="hljs-string">"pose"</span>)
        pose.<span class="hljs-attr">text</span> = <span class="hljs-string">"Unspecified"</span>

        <span class="hljs-attr">truncated</span> = etree.SubElement(object, <span class="hljs-string">"truncated"</span>)
        truncated.<span class="hljs-attr">text</span> = <span class="hljs-string">"0"</span>

        <span class="hljs-attr">difficult</span> = etree.SubElement(object, <span class="hljs-string">"difficult"</span>)
        difficult.<span class="hljs-attr">text</span> = <span class="hljs-string">"0"</span>

        <span class="hljs-attr">bndbox</span> = etree.SubElement(object, <span class="hljs-string">"bndbox"</span>)
        <span class="hljs-attr">xmin</span> = etree.SubElement(bndbox, <span class="hljs-string">"xmin"</span>)
        xmin.<span class="hljs-attr">text</span> = <span class="hljs-string">"%d"</span> % (x_min_rect)
        <span class="hljs-attr">ymin</span> = etree.SubElement(bndbox, <span class="hljs-string">"ymin"</span>)
        ymin.<span class="hljs-attr">text</span> = <span class="hljs-string">"%d"</span> % (y_min_rect)
        <span class="hljs-attr">xmax</span> = etree.SubElement(bndbox, <span class="hljs-string">"xmax"</span>)
        xmax.<span class="hljs-attr">text</span> = <span class="hljs-string">"%d"</span> % (x_max_rect)
        <span class="hljs-attr">ymax</span> = etree.SubElement(bndbox, <span class="hljs-string">"ymax"</span>)
        ymax.<span class="hljs-attr">text</span> = <span class="hljs-string">"%d"</span> % (y_max_rect)

        root.append(object)

    <span class="hljs-attr">file_output</span> = etree.tostring(root, <span class="hljs-attr">pretty_print=True,</span> <span class="hljs-attr">encoding='UTF-8')</span>
    <span class="hljs-comment"># print(file_output.decode('utf-8'))</span>
    <span class="hljs-attr">ff</span> = open('%s.xml' % (img_name[:-<span class="hljs-number">4</span>]), 'w', <span class="hljs-attr">encoding="utf-8")</span>
    ff.write(file_output.decode('utf-<span class="hljs-number">8</span>'))
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="third-create-a-tf-record-from-the-pascal-voc-data"></a><a href="#third-create-a-tf-record-from-the-pascal-voc-data" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Third, create a TF-RECORD from the PASCAL-VOC data</h3>
<p>The preferred way to carry out this procedure seems to change regularly, so it can be tricky to find out this information. Let's start by creating a new <code>conda</code> environment for this task, callled <code>tf_test_py36</code>, containing a specific version of python (my current go-to at the time of writing is 3.6 rather than the stable 3.7, because of dependency issues that can sometimes arise on Windows OS)</p>
<pre><code class="hljs">conda <span class="hljs-built_in">create</span> <span class="hljs-comment">--name tf_test_py36 python=3.6 tensorflow lxml contextlib2</span>
</code></pre>
<p>and activate:</p>
<pre><code class="hljs">conda <span class="hljs-built_in">activate</span> tf_test_py36
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="getting-tensorflow-garden-set-up"></a><a href="#getting-tensorflow-garden-set-up" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Getting Tensorflow Garden set up</h4>
<p>Clone the <a href="https://github.com/tensorflow/models/blob/master/official/README.md">Tensorflow Garden</a> GitHub repository:</p>
<pre><code class="hljs">git <span class="hljs-keyword">clone</span> <span class="hljs-title">https</span>://github.com/tensorflow/models.git
</code></pre>
<p>Add the top-level /models folder to your system Python path.</p>
<pre><code class="hljs">export PYTHONPATH=<span class="hljs-variable">$PYTHONPATH</span><span class="hljs-symbol">:/media/marda/TWOTB/USGS/SOFTWARE/models</span>
</code></pre>
<p>Install other dependencies:</p>
<pre><code class="hljs">pip install <span class="hljs-params">--user</span> -r official/requirements.txt
<span class="hljs-keyword">cd</span> research
protoc object_detection/protos/*<span class="hljs-string">.proto</span> <span class="hljs-params">--python_out=</span>.
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="create-the-tf-record"></a><a href="#create-the-tf-record" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Create the tf-record</h4>
<p>(Your current directory should be <code>models/research</code>)</p>
<p>This workflow is specific to the <code>POB</code> (People on Beaches) dataset that only has one label, so first, create a file called <code>object_detection/data/pob_label_map.pbtxt</code> and copy the following into it:</p>
<pre><code class="hljs"><span class="hljs-selector-tag">item</span> {
  <span class="hljs-attribute">id</span>: <span class="hljs-number">1</span>
  name: <span class="hljs-string">'person'</span>
}
</code></pre>
<p>Second, create a new file called <code>POB_images</code>, and copy all your jpg files and corresponding xml files into it - all together</p>
<p>Third, create a new file <code>object_detection/dataset_tools/create_pob_tf_record.py</code> and copy the following code into it. The variable <code>num_shards</code> is the number of pieces you'd like to create. It matters not for this dataset; we use 10.</p>
<pre><code class="hljs">from glob <span class="hljs-keyword">import</span> glob
<span class="hljs-keyword">import</span> hashlib, io, os, logging, random, re, contextlib2
from lxml <span class="hljs-keyword">import</span> etree
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-keyword">import</span> PIL.Image
<span class="hljs-keyword">import</span> tensorflow.compat.v1 <span class="hljs-keyword">as</span> tf

from object_detection.dataset_tools <span class="hljs-keyword">import</span> tf_record_creation_util
from object_detection.utils <span class="hljs-keyword">import</span> dataset_util
from object_detection.utils <span class="hljs-keyword">import</span> label_map_util

flags = tf.app.flags
flags.DEFINE_string(<span class="hljs-string">'data_dir'</span>, <span class="hljs-string">''</span>, <span class="hljs-string">'Root directory to raw pet dataset.'</span>)
flags.DEFINE_string(<span class="hljs-string">'output_dir'</span>, <span class="hljs-string">''</span>, <span class="hljs-string">'Path to directory to output TFRecords.'</span>)
flags.DEFINE_string(<span class="hljs-string">'label_map_path'</span>, <span class="hljs-string">'data/pet_label_map.pbtxt'</span>,
                    <span class="hljs-string">'Path to label map proto'</span>)
flags.DEFINE_integer(<span class="hljs-string">'num_shards'</span>, <span class="hljs-number">10</span>, <span class="hljs-string">'Number of TFRecord shards'</span>)

FLAGS = flags.FLAGS
</code></pre>
<p>The following is the main function that gets called to carry out the conversion. It creates a single <code>tf.Example</code> message (or protobuf), which is a flexible message type that represents a <code>{&quot;string&quot;: value}</code> mapping</p>
<pre><code class="hljs">def dict_to_tf_example(data,
                       label_map_dict,
                       image_subdirectory,
                       ignore_difficult_instances=False):
  <span class="hljs-string">""</span><span class="hljs-comment">"Convert XML derived dict to tf.Example proto.</span>

  Notice that this <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">normalizes</span> <span class="hljs-title">the</span> <span class="hljs-title">bounding</span> <span class="hljs-title">box</span> <span class="hljs-title">coordinates</span> <span class="hljs-title">provided</span></span>
  by the raw data.

  Arg<span class="hljs-variable">s:</span>
    dat<span class="hljs-variable">a:</span> dict holding PASCAL XML fields <span class="hljs-keyword">for</span> <span class="hljs-keyword">a</span> single image (obtained by
      running dataset_util.recursive_parse_xml_to_dict)
    label_map_dic<span class="hljs-variable">t:</span> A <span class="hljs-keyword">map</span> from <span class="hljs-built_in">string</span> label names <span class="hljs-keyword">to</span> integers ids.
    image_subdirectory: String specifying subdirectory within the
      Pascal dataset directory holding the actual image data.
    ignore_difficult_instance<span class="hljs-variable">s:</span> Whether <span class="hljs-keyword">to</span> skip difficult instances in the
      dataset  (defaul<span class="hljs-variable">t:</span> False).

  Return<span class="hljs-variable">s:</span>
    example: The converted <span class="hljs-keyword">tf</span>.Example.

  Raise<span class="hljs-variable">s:</span>
    ValueError: <span class="hljs-keyword">if</span> the image pointed <span class="hljs-keyword">to</span> by data[<span class="hljs-string">'filename'</span>] <span class="hljs-keyword">is</span> not <span class="hljs-keyword">a</span> valid JPEG
  <span class="hljs-string">""</span><span class="hljs-comment">"</span>
  img_path = os.path.<span class="hljs-keyword">join</span>(image_subdirectory, data[<span class="hljs-string">'filename'</span>])
  with <span class="hljs-keyword">tf</span>.gfile.GFile(img_path, <span class="hljs-string">'rb'</span>) <span class="hljs-keyword">as</span> fid:
    encoded_jpg = fid.<span class="hljs-keyword">read</span>()
  encoded_jpg_io = io.BytesIO(encoded_jpg)
  image = PIL.Image.<span class="hljs-keyword">open</span>(encoded_jpg_io)
  <span class="hljs-keyword">if</span> image.format != <span class="hljs-string">'JPEG'</span>:
    raise ValueError(<span class="hljs-string">'Image format not JPEG'</span>)
  key = hashlib.<span class="hljs-built_in">sha256</span>(encoded_jpg).hexdigest()

  width = <span class="hljs-keyword">int</span>(data[<span class="hljs-string">'size'</span>][<span class="hljs-string">'width'</span>])
  height = <span class="hljs-keyword">int</span>(data[<span class="hljs-string">'size'</span>][<span class="hljs-string">'height'</span>])

  xmins = []
  ymins = []
  xmaxs = []
  ymaxs = []
  classes = []
  classes_text = []
  truncated = []
  poses = []
  difficult_obj = []
  <span class="hljs-keyword">if</span> <span class="hljs-string">'object'</span> in dat<span class="hljs-variable">a:</span>
    <span class="hljs-keyword">for</span> obj in data[<span class="hljs-string">'object'</span>]:
      difficult = bool(<span class="hljs-keyword">int</span>(obj[<span class="hljs-string">'difficult'</span>]))
      <span class="hljs-keyword">if</span> ignore_difficult_instances <span class="hljs-built_in">and</span> difficul<span class="hljs-variable">t:</span>
        <span class="hljs-keyword">continue</span>
      difficult_obj.<span class="hljs-keyword">append</span>(<span class="hljs-keyword">int</span>(difficult))

      xmin = float(obj[<span class="hljs-string">'bndbox'</span>][<span class="hljs-string">'xmin'</span>])
      xmax = float(obj[<span class="hljs-string">'bndbox'</span>][<span class="hljs-string">'xmax'</span>])
      ymin = float(obj[<span class="hljs-string">'bndbox'</span>][<span class="hljs-string">'ymin'</span>])
      ymax = float(obj[<span class="hljs-string">'bndbox'</span>][<span class="hljs-string">'ymax'</span>])

      xmins.<span class="hljs-keyword">append</span>(xmin / width)
      ymins.<span class="hljs-keyword">append</span>(ymin / height)
      xmaxs.<span class="hljs-keyword">append</span>(xmax / width)
      ymaxs.<span class="hljs-keyword">append</span>(ymax / height)
      class_name = <span class="hljs-string">'person'</span> #get_class_name_from_filename(data[<span class="hljs-string">'filename'</span>])
      classes_text.<span class="hljs-keyword">append</span>(class_name.encode(<span class="hljs-string">'utf8'</span>))
      classes.<span class="hljs-keyword">append</span>(label_map_dict[class_name])
      truncated.<span class="hljs-keyword">append</span>(<span class="hljs-keyword">int</span>(obj[<span class="hljs-string">'truncated'</span>]))
      poses.<span class="hljs-keyword">append</span>(obj[<span class="hljs-string">'pose'</span>].encode(<span class="hljs-string">'utf8'</span>))

  feature_dict = {
      <span class="hljs-string">'image/height'</span>: dataset_util.int64_feature(height),
      <span class="hljs-string">'image/width'</span>: dataset_util.int64_feature(width),
      <span class="hljs-string">'image/filename'</span>: dataset_util.bytes_feature(
          data[<span class="hljs-string">'filename'</span>].encode(<span class="hljs-string">'utf8'</span>)),
      <span class="hljs-string">'image/source_id'</span>: dataset_util.bytes_feature(
          data[<span class="hljs-string">'filename'</span>].encode(<span class="hljs-string">'utf8'</span>)),
      <span class="hljs-string">'image/key/sha256'</span>: dataset_util.bytes_feature(key.encode(<span class="hljs-string">'utf8'</span>)),
      <span class="hljs-string">'image/encoded'</span>: dataset_util.bytes_feature(encoded_jpg),
      <span class="hljs-string">'image/format'</span>: dataset_util.bytes_feature(<span class="hljs-string">'jpeg'</span>.encode(<span class="hljs-string">'utf8'</span>)),
      <span class="hljs-string">'image/object/bbox/xmin'</span>: dataset_util.float_list_feature(xmins),
      <span class="hljs-string">'image/object/bbox/xmax'</span>: dataset_util.float_list_feature(xmaxs),
      <span class="hljs-string">'image/object/bbox/ymin'</span>: dataset_util.float_list_feature(ymins),
      <span class="hljs-string">'image/object/bbox/ymax'</span>: dataset_util.float_list_feature(ymaxs),
      <span class="hljs-string">'image/object/class/text'</span>: dataset_util.bytes_list_feature(classes_text),
      <span class="hljs-string">'image/object/class/label'</span>: dataset_util.int64_list_feature(classes),
      <span class="hljs-string">'image/object/difficult'</span>: dataset_util.int64_list_feature(difficult_obj),
      <span class="hljs-string">'image/object/truncated'</span>: dataset_util.int64_list_feature(truncated),
      <span class="hljs-string">'image/object/view'</span>: dataset_util.bytes_list_feature(poses),
  }

  example = <span class="hljs-keyword">tf</span>.train.Example(features=<span class="hljs-keyword">tf</span>.train.Features(feature=feature_dict))
  <span class="hljs-keyword">return</span> example
</code></pre>
<p>This portion does the file writing (i.e. creates the <code>.tfrecord</code> files from the collection of <code>tf.Example</code> records):</p>
<pre><code class="hljs">def create_tf_record(output_filename,
                     num_shards,
                     label_map_dict,
                     annotations_dir,
                     image_dir,
                     examples):
  <span class="hljs-string">""</span><span class="hljs-comment">"Creates a TFRecord file from examples.</span>

  Arg<span class="hljs-variable">s:</span>
    output_filename: Path <span class="hljs-keyword">to</span> where output <span class="hljs-keyword">file</span> <span class="hljs-keyword">is</span> saved.
    num_shard<span class="hljs-variable">s:</span> Number of shards <span class="hljs-keyword">for</span> output <span class="hljs-keyword">file</span>.
    label_map_dic<span class="hljs-variable">t:</span> The label <span class="hljs-keyword">map</span> dictionary.
    annotations_dir: Directory where annotation <span class="hljs-keyword">files</span> are stored.
    image_dir: Directory where image <span class="hljs-keyword">files</span> are stored.
    example<span class="hljs-variable">s:</span> Examples <span class="hljs-keyword">to</span> parse <span class="hljs-built_in">and</span> save <span class="hljs-keyword">to</span> <span class="hljs-keyword">tf</span> record.
  <span class="hljs-string">""</span><span class="hljs-comment">"</span>
  with contextlib2.ExitStack() <span class="hljs-keyword">as</span> tf_record_close_stack:
    output_tfrecords = tf_record_creation_util.open_sharded_output_tfrecords(
        tf_record_close_stack, output_filename, num_shards)
    <span class="hljs-keyword">for</span> idx, example in enumerate(examples):
      <span class="hljs-keyword">if</span> idx % <span class="hljs-number">100</span> == <span class="hljs-number">0</span>:
        logging.info(<span class="hljs-string">'On image %d of %d'</span>, idx, <span class="hljs-built_in">len</span>(examples))
      xml_path = os.path.<span class="hljs-keyword">join</span>(annotations_dir, <span class="hljs-string">'xmls'</span>, example.<span class="hljs-keyword">split</span>(<span class="hljs-string">'.jpg'</span>)[<span class="hljs-number">0</span>] + <span class="hljs-string">'.xml'</span>)

      <span class="hljs-keyword">if</span> not os.path.<span class="hljs-built_in">exists</span>(xml_path):
        logging.warning(<span class="hljs-string">'Could not find %s, ignoring example.'</span>, xml_path)
        <span class="hljs-keyword">continue</span>
      with <span class="hljs-keyword">tf</span>.gfile.GFile(xml_path, <span class="hljs-string">'r'</span>) <span class="hljs-keyword">as</span> fid:
        xml_str = fid.<span class="hljs-keyword">read</span>()
      xml = etree.fromstring(xml_str)
      data = dataset_util.recursive_parse_xml_to_dict(xml)[<span class="hljs-string">'annotation'</span>]

      <span class="hljs-keyword">try</span>:
        tf_example = dict_to_tf_example(
            data,
            label_map_dict,
            image_dir)
        <span class="hljs-keyword">if</span> tf_example:
          shard_idx = idx % num_shards
          output_tfrecords[shard_idx].<span class="hljs-keyword">write</span>(tf_example.SerializeToString())
      except ValueError:
        logging.warning(<span class="hljs-string">'Invalid example: %s, ignoring.'</span>, xml_path)
</code></pre>
<p>The <code>main</code> function reads all the jpg files in <code>POB_images</code>, as well as all the <code>xml</code> files in the same directory. Note that this could be set up differently, to read the <code>xml</code> files from a separate <code>annotations_dir</code>. The files are randomly shuffled. The number of training examples is 70% of the total, and the remaining 30% of files are used for validation. It then calls the <code>create_tf_record</code> function to create the <code>.tfrecord</code> set of 10 files.</p>
<pre><code class="hljs">def main(_):
  data_dir = FLAGS.data_dir
  label_map_dict = label_map_util.get_label_map_dict(FLAGS.label_map_path)

  logging.<span class="hljs-keyword">info</span>(<span class="hljs-string">'Reading from POB dataset.'</span>)
  image_dir = annotations_dir = os.path.<span class="hljs-keyword">join</span>(data_dir, <span class="hljs-string">'POB_images'</span>)

  examples_list = glob(image_dir+<span class="hljs-string">'/*.jpg'</span>)

  # Test images are <span class="hljs-keyword">not</span> included <span class="hljs-keyword">in</span> the downloaded data <span class="hljs-keyword">set</span>, so we shall <span class="hljs-keyword">perform</span>
  # our own split.
  random.seed(<span class="hljs-number">42</span>)
  random.shuffle(examples_list)
  num_examples = len(examples_list)
  num_train = <span class="hljs-type">int</span>(<span class="hljs-number">0.7</span> * num_examples)
  train_examples = examples_list[:num_train]
  val_examples = examples_list[num_train:]
  logging.<span class="hljs-keyword">info</span>(<span class="hljs-string">'%d training and %d validation examples.'</span>,
               len(train_examples), len(val_examples))

  train_output_path = os.path.<span class="hljs-keyword">join</span>(FLAGS.output_dir, <span class="hljs-string">'pob_train.record'</span>)
  val_output_path = os.path.<span class="hljs-keyword">join</span>(FLAGS.output_dir, <span class="hljs-string">'pob_val.record'</span>)

  # <span class="hljs-keyword">call</span> <span class="hljs-keyword">to</span> <span class="hljs-keyword">create</span> the training files
  create_tf_record(
      train_output_path,
      FLAGS.num_shards,
      label_map_dict,
      annotations_dir,
      image_dir,
      train_examples)

# <span class="hljs-keyword">call</span> again <span class="hljs-keyword">to</span> make the validation <span class="hljs-keyword">set</span>
  create_tf_record(
      val_output_path,
      FLAGS.num_shards,
      label_map_dict,
      annotations_dir,
      image_dir,
      val_examples)

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
  tf.app.run()

</code></pre>
<p>And finally, run the script and make your tf-record format data ...</p>
<pre><code class="hljs">python object_detection/dataset_tools/create_pob_tf_record.py <span class="hljs-attribute">--label_map_path</span>=object_detection/data/POB_label_map.pbtxt  <span class="hljs-attribute">--data_dir</span>=`pwd` <span class="hljs-attribute">--output_dir</span>=`pwd`
</code></pre>
<p>This will create 10 files for the training data, and 10 for the validation set. You can now use these files to efficiently train a model using Tensoflow/Keras.</p>
<h3><a class="anchor" aria-hidden="true" id="optional-xml-to-csv"></a><a href="#optional-xml-to-csv" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>[OPTIONAL] XML to CSV</h3>
<p>Sometimes you also see people use object annotations in csv format. Luckily we can use the <code>xml</code> library to help carry out the data parsing, and <code>pandas</code> to easily convert to a dataframe, and then to a formatted csv file</p>
<pre><code class="hljs"><span class="hljs-keyword">import</span> os, glob
<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
<span class="hljs-keyword">import</span> <span class="hljs-type">xml</span>.etree.ElementTree <span class="hljs-keyword">as</span> ET

def xml_to_csv(<span class="hljs-type">path</span>):
    xml_list = []
    <span class="hljs-keyword">for</span> xml_file <span class="hljs-keyword">in</span> glob.glob(<span class="hljs-type">path</span> + <span class="hljs-string">'/*.xml'</span>):
        tree = ET.parse(xml_file)
        root = tree.getroot()
        <span class="hljs-keyword">for</span> member <span class="hljs-keyword">in</span> root.findall(<span class="hljs-string">'object'</span>):
            <span class="hljs-keyword">value</span> = (root.find(<span class="hljs-string">'filename'</span>).text,
                     <span class="hljs-type">int</span>(root.find(<span class="hljs-string">'size'</span>)[<span class="hljs-number">0</span>].text),
                     <span class="hljs-type">int</span>(root.find(<span class="hljs-string">'size'</span>)[<span class="hljs-number">1</span>].text),
                     member[<span class="hljs-number">0</span>].text,
                     <span class="hljs-type">int</span>(member[<span class="hljs-number">4</span>][<span class="hljs-number">0</span>].text),
                     <span class="hljs-type">int</span>(member[<span class="hljs-number">4</span>][<span class="hljs-number">1</span>].text),
                     <span class="hljs-type">int</span>(member[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>].text),
                     <span class="hljs-type">int</span>(member[<span class="hljs-number">4</span>][<span class="hljs-number">3</span>].text)
                     )
            xml_list.append(<span class="hljs-keyword">value</span>)
    <span class="hljs-built_in">column_name</span> = [<span class="hljs-string">'filename'</span>, <span class="hljs-string">'width'</span>, <span class="hljs-string">'height'</span>, <span class="hljs-string">'class'</span>, <span class="hljs-string">'xmin'</span>, <span class="hljs-string">'ymin'</span>, <span class="hljs-string">'xmax'</span>, <span class="hljs-string">'ymax'</span>]
    xml_df = pd.DataFrame(xml_list, <span class="hljs-keyword">columns</span>=<span class="hljs-built_in">column_name</span>)
    <span class="hljs-keyword">return</span> xml_df

</code></pre>
<p>Then use like this:</p>
<pre><code class="hljs">image_path = os.path.join(os.getcwd<span class="hljs-literal">()</span>,'test_labels_xml')
xml_df = xml<span class="hljs-constructor">_to_csv(<span class="hljs-params">image_path</span>)</span>
xml_df.<span class="hljs-keyword">to</span><span class="hljs-constructor">_csv('<span class="hljs-params">test_labels</span>.<span class="hljs-params">csv</span>', <span class="hljs-params">index</span>=None)</span>
</code></pre>
</span></div></article></div><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/MLMONDAYS/blog/2020/08/05/blog-post">Trimming and decompiling a video into png image files, for use in your deep learning project</a></h1><p class="post-meta">August 5, 2020</p><div class="authorBlock"><p class="post-authorName"><a href="http://twitter.com/magic_walnut" target="_blank" rel="noreferrer noopener">Dan Buscombe</a></p></div></header><article class="post-content"><div><span><p><img src="/MLMONDAYS/blog/assets/secoora.png" alt=""></p>
<p>You can access from the NOAA NOS Web Camera Applications Testbed (WebCAT) <a href="https://secoora.org/webcat/">Live Cameras and Historic Feeds</a> site. The image above shows how to view the image I will use in the demonstration below.</p>
<p>To extract a subsection (or trim) of the file  <code>staugustinecam.2019-01-11_0900.mp4</code>, from 1 min 47 s to 6 min 22 s, and output it to the file <code>staugustinecam.2019-01-11_0900_trim.mp4</code>:</p>
<pre><code class="hljs">ffmpeg -i staugustinecam<span class="hljs-number">.2019</span><span class="hljs-number">-01</span><span class="hljs-number">-11</span>_0900.mp4 -ss <span class="hljs-number">00</span>:<span class="hljs-number">01</span>:<span class="hljs-number">47</span> -t <span class="hljs-number">00</span>:<span class="hljs-number">06</span>:<span class="hljs-number">22</span> -async <span class="hljs-number">1</span> staugustinecam<span class="hljs-number">.2019</span><span class="hljs-number">-01</span><span class="hljs-number">-11</span>_0900_trim.mp4
</code></pre>
<p>To extract <code>png</code> format files from that trimmed video, writing the frame number to the file name:</p>
<pre><code class="hljs">ffmpeg -i staugustinecam<span class="hljs-number">.2019</span><span class="hljs-number">-01</span><span class="hljs-number">-11</span>_0900_trim.mp4 staugustinecam<span class="hljs-number">.2019</span><span class="hljs-number">-01</span><span class="hljs-number">-11</span>_0900_%d.png
</code></pre>
<p>Make a directory:</p>
<pre><code class="hljs">mkdir staugustinecam_2019<span class="hljs-number">-01</span><span class="hljs-number">-11</span>_0900
</code></pre>
<p>Move all of the <code>png</code> files into that directory:</p>
<pre><code class="hljs">mv *.png staugustinecam_2019<span class="hljs-number">-01</span><span class="hljs-number">-11</span>_0900
</code></pre>
<p>Make a bash script so you can execute the decompiling (only) sequence of commands on an arbitrary mp4 file from the command line. First, open a new file called <code>nano decompile_mp4.sh</code>:</p>
<pre><code class="hljs"><span class="hljs-selector-tag">nano</span> <span class="hljs-selector-tag">decompile_mp4</span><span class="hljs-selector-class">.sh</span>
</code></pre>
<p>and write or copy the following into it:</p>
<pre><code class="hljs">echo <span class="hljs-string">"decompiling video file $1, and moving png frames into $2, in T minus 5 seconds ..."</span>
<span class="hljs-keyword">sleep</span> <span class="hljs-number">5</span><span class="hljs-keyword">s</span>
ffmpeg -i $1 $2<span class="hljs-number">_</span>%d.png
<span class="hljs-keyword">mkdir</span> $2
mv *.png $2
</code></pre>
<p>To exit <code>nano</code>:</p>
<p><code>Ctrl+X</code> (for exit)
<code>Y</code> (for yes)
<code>enter</code> (for save)</p>
<p>Use it like this:</p>
<pre><code class="hljs"><span class="hljs-selector-tag">bash</span> <span class="hljs-selector-tag">decompile_mp4</span><span class="hljs-selector-class">.sh</span> <span class="hljs-selector-tag">myvid</span><span class="hljs-selector-class">.mp4</span> <span class="hljs-selector-tag">myframes</span>
</code></pre>
<p>To extract 1 frame per minute, modify to:</p>
<pre><code class="hljs">echo <span class="hljs-string">"decompiling video file $1 - one frame every minute, and moving png frames into $2, in T minus 5 seconds ..."</span>
<span class="hljs-keyword">sleep</span> <span class="hljs-number">5</span><span class="hljs-keyword">s</span>
ffmpeg -i $1 -vf fps=<span class="hljs-number">1</span>/<span class="hljs-number">60</span> $2<span class="hljs-number">_</span>%d.png
<span class="hljs-keyword">mkdir</span> $2
mv *.png $2
</code></pre>
<p>Let's say you've carried out the above procedure on lots of videos and you have lots of folders containing frames. Now you want to randomly move some images from each directory into three separate folders that you'll use in your deep learning project, called <code>test</code>, <code>train</code>, and <code>validate</code> (it is also common to use <code>test</code> for the purposes of both testing and validating)</p>
<pre><code class="hljs"><span class="hljs-keyword">mkdir</span> train
<span class="hljs-keyword">mkdir</span> <span class="hljs-keyword">test</span>
<span class="hljs-keyword">mkdir</span> validate
</code></pre>
<p>To move 10 random files to each from a directory called <code>my_directory</code> containing png frames:</p>
<pre><code class="hljs">cd my_directory
shuf -n <span class="hljs-number">10</span> -e * | xargs -i <span class="hljs-class">mv </span>{} ..<span class="hljs-meta-keyword">/train/</span>
shuf -n <span class="hljs-number">10</span> -e * | xargs -i <span class="hljs-class">mv </span>{} ..<span class="hljs-meta-keyword">/test/</span>
shuf -n <span class="hljs-number">10</span> -e * | xargs -i <span class="hljs-class">mv </span>{} ..<span class="hljs-meta-keyword">/validate/</span>
</code></pre>
<p>or to generalize:</p>
<pre><code class="hljs"><span class="hljs-keyword">for</span> direc <span class="hljs-keyword">in</span> st*/
<span class="hljs-keyword">do</span>
<span class="hljs-built_in">cd</span> <span class="hljs-variable">$direc</span>
shuf -n 10 -e * | xargs -i mv {} ../train/
shuf -n 10 -e * | xargs -i mv {} ../<span class="hljs-built_in">test</span>/
shuf -n 10 -e * | xargs -i mv {} ../validate/  
<span class="hljs-built_in">cd</span> ..
<span class="hljs-keyword">done</span>
</code></pre>
<p>In the above, I say <code>st*/</code> to list only directories beginning with <code>st</code>, rather than listing all directories (<code>/*</code>), which would include <code>test</code>, <code>train</code>, and <code>validate</code> and would not work</p>
<p>Finally, to convert all png files to jpg files, use:</p>
<pre><code class="hljs"><span class="hljs-attribute">mogrify</span> -format jpg <span class="hljs-regexp">*.png</span>
</code></pre>
</span></div></article></div><div class="docs-prevnext"></div></div></div></div></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/MLMONDAYS/" class="nav-home"><img src="/MLMONDAYS/img/favicon.ico" alt="&quot;ML Mondays&quot;" width="66" height="58"/></a><div><h5>Internal links</h5><a href="/MLMONDAYS/docs/en/doc1.html">Docs</a><a href="/MLMONDAYS/docs/en/doc2.html">Data</a><a href="/MLMONDAYS/docs/en/doc3.html">Help</a></div><div><h5>Community</h5><a href="https://stackoverflow.com/questions/tagged/" target="_blank" rel="noreferrer noopener">Stack Overflow</a><a href="https://www.usgs.gov/centers/cdi" target="_blank" rel="noreferrer noopener">USGS Community for Data Integration (CDI)</a><a href="https://www.usgs.gov/centers/pcmsc/science/remote-sensing-coastal-change?qt-science_center_objects=0#qt-science_center_objects" target="_blank" rel="noreferrer noopener">USGS Remote Sensing Coastal Change Project</a><a href="https://www.danielbuscombe.com" target="_blank" rel="noreferrer noopener">www.danielbuscombe.com</a></div><div><h5>More</h5><a href="/MLMONDAYS/blog">Blog</a><a href="https://github.com/dbuscombe-usgs/DL-CDI2020">GitHub</a><a class="github-button" data-icon="octicon-star" data-count-href="/facebook/docusaurus/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">Star</a><div class="social"><a href="https://twitter.com/magic_walnut" class="twitter-follow-button">Follow @magic_walnut</a></div></div></section><a href="https://mardascience.com/" target="_blank" rel="noreferrer noopener" class="fbOpenSource"><img src="/MLMONDAYS/img/dash-logo-new.png" alt="Marda Science" width="170" height="45"/></a><section class="copyright">Copyright © 2020 Marda Science, LLC</section></footer></div><script>window.twttr=(function(d,s, id){var js,fjs=d.getElementsByTagName(s)[0],t=window.twttr||{};if(d.getElementById(id))return t;js=d.createElement(s);js.id=id;js.src='https://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js, fjs);t._e = [];t.ready = function(f) {t._e.push(f);};return t;}(document, 'script', 'twitter-wjs'));</script></body></html>